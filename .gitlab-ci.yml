stages:
  - build
  - publish
  - test
  - terraform-plan
  - terraform-deploy

workflow:
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
      when: never
    - if: $CI_PIPELINE_SOURCE == "push"
    - if: $CI_PIPELINE_SOURCE == "web"

variables:
  GRADLE_IMAGE: gradle:jdk11
  AWS_CLI_IMAGE: amazon/aws-cli
  TERRAFORM_IMAGE: hashicorp/terraform

build-jar: # package app into runnable JAR
  stage: build
  image: $GRADLE_IMAGE
  script:
   - export GRADLE_USER_HOME=`pwd`/.gradle
   - chmod +x gradlew
   - ./gradlew bootJar
   - echo Packaged app JAR "$APP_NAME".jar
  cache:
    key: $CI_COMMIT_SHORT_SHA
    policy: push
    paths:
      - build
      - .gradle
  artifacts:
    paths:
      - build/libs
    expire_in: 1 hour

upload-jar: # upload runnable JAR to S3 -> to be downloaded to EC2 instance
  stage: publish
  image: $AWS_CLI_IMAGE
  script:
    - export ARTIFACT_VERSIONED_NAME="$APP_NAME"_"$CI_COMMIT_SHORT_SHA"
    - echo Versioned artifact name based on commit hash is "$ARTIFACT_VERSIONED_NAME"
    - echo Uploading artifact "$APP_NAME".jar as "$ARTIFACT_VERSIONED_NAME".jar to S3 bucket "$ARTIFACTS_BUCKET_NAME"
    - aws s3api put-object --bucket $ARTIFACTS_BUCKET_NAME --key "$ARTIFACT_VERSIONED_NAME".jar --body ./build/libs/"$APP_NAME".jar
    - echo Artifact upload successful
  needs:
    - build-jar
  only:
    - main

delete-jar: # cleanup job -> delete JAR from artifacts bucket
  stage: publish
  image: $AWS_CLI_IMAGE
  script:
    - export ARTIFACT_VERSIONED_NAME="$APP_NAME"_"$CI_COMMIT_SHORT_SHA"
    - echo Deleting artifact "$ARTIFACT_VERSIONED_NAME".jar from s3 bucket "$ARTIFACTS_BUCKET_NAME"
    - aws s3 rm s3://"$ARTIFACTS_BUCKET_NAME"/"$ARTIFACT_VERSIONED_NAME".jar
    - echo Artifact successfully removed from S3 bucket "$ARTIFACTS_BUCKET_NAME"
  needs:
    - upload-jar
  only:
    - main
  when: manual
  allow_failure: true

spotless-check:
  stage: test
  image: $GRADLE_IMAGE
  script:
    - export GRADLE_USER_HOME=`pwd`/.gradle
    - chmod +x gradlew
    - echo "Performing spotless check..."
    - ./gradlew spotlessCheck
  except:
    variables:
      - $SKIP_SPOTLESS_CHECK
  allow_failure: true

unit-test:
  stage: test
  image: $GRADLE_IMAGE
  script:
    - export GRADLE_USER_HOME=`pwd`/.gradle
    - chmod +x gradlew
    - echo "Running unit tests..."
    - ./gradlew test
  cache:
    key: $CI_COMMIT_SHORT_SHA
    policy: pull
    paths:
      - build
      - .gradle

integration-test:
  stage: test
  image: $GRADLE_IMAGE
  script:
    - export GRADLE_USER_HOME=`pwd`/.gradle
    - chmod +x gradlew
    - echo "Running integration tests..."
    - ./gradlew integrationTest
  cache:
    key: $CI_COMMIT_SHORT_SHA
    policy: pull
    paths:
      - build
      - .gradle

terraform-init:
  stage: terraform-plan
  image: $TERRAFORM_IMAGE
  script:
    - cd ./terraform
    - echo Initializing terraform
    - terraform init 
      -backend-config=backend.hcl 
      -backend-config="region=$AWS_DEFAULT_REGION"
      -backend-config="access_key=$TERRAFORM_AWS_ACCESS_KEY"
      -backend-config="secret_key=$TERRAFORM_AWS_SECRET_KEY"
  cache:
    key: $CI_COMMIT_SHORT_SHA
    policy: push
    paths:
      - ./terraform/.terraform
  artifacts:
    paths:
      - ./terraform/.terraform
    expire_in: 1 hour

terraform-validate:
  stage: terraform-plan
  image: $TERRAFORM_IMAGE
  script:
    - cd ./terraform
    - echo Validating Terraform configurations
    - terraform validate
  cache:
    key: $CI_COMMIT_SHORT_SHA
    policy: pull
    paths:
      - ./terraform/.terraform
  needs:
    - terraform-init
  dependencies:
    - terraform-init

terraform-plan:
  stage: terraform-plan
  image: $TERRAFORM_IMAGE
  script:
    - export ARTIFACT_VERSIONED_NAME="$APP_NAME"_"$CI_COMMIT_SHORT_SHA".jar
    - cd ./terraform
    - echo Create Terraform plan...
    - terraform plan -out=tfplan 
      -var-file=inputs.tfvars 
      -var environment="$ENVIRONMENT" 
      -var aws_access_key="$TERRAFORM_AWS_ACCESS_KEY" 
      -var aws_secret_key="$TERRAFORM_AWS_SECRET_KEY" 
      -var aws_account_id="$AWS_ACCOUNT_ID" 
      -var "artifacts_bucket_name="$ARTIFACTS_BUCKET_NAME" 
      -var "application_artifact_name="$ARTIFACT_VERSIONED_NAME"
    - echo Plan complete, review carefully!
  cache:
    key: $CI_COMMIT_SHORT_SHA
    policy: pull
    paths:
      - ./terraform/.terraform
  artifacts:
    paths:
      - ./terraform/tfplan
    expire_in: 1 hour
  needs:
    - terraform-init
    - terraform-validate
  dependencies:
    - terraform-init

terraform-apply:
  stage: terraform-deploy
  image: $TERRAFORM_IMAGE
  script:
    - cd ./terraform
    - echo Applying terraform plan to create infrastructure...
    - terraform apply "tfplan"
    - echo Infrastructure created for app '$APP_NAME' on environment '$ENVIRONMENT'!
    - echo Do not manually modify resources created by Terraform!
    - echo Resources managed by Terraform are tagged 'managed_by=terraform' where possible.
  cache:
    key: $CI_COMMIT_SHORT_SHA
    policy: pull
    paths:
      - ./terraform/.terraform
  artifacts: # export private SSH key as artifact -> can be used to connect to instance
    paths:
      - ./terraform/ssh_keys/sample-app-private-key-rsa
    expire_in: 1 hour
  dependencies:
    - terraform-init
    - terraform-plan
  when: manual
  only:
    - main

terraform-destroy:
  stage: terraform-deploy
  image: $TERRAFORM_IMAGE
  script:
    - cd ./terraform
    - echo Destroying infrastructure...
    - terraform destroy
    - echo Infrastructure was destroyed successfully!
  cache:
    key: $CI_COMMIT_SHORT_SHA
    policy: pull
    paths:
      - ./terraform/.terraform
  when: manual
  only:
    - main
  needs:
    - terraform-init
    - terraform-plan
    - terraform-apply
  dependencies:
    - terraform-init
    - terraform-plan

