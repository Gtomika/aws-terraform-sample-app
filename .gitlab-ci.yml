stages:
  - build # build app and upload JAR to S3
  - publish # artifact management
  - test # run tests and checks
  - terraform # terraform init, fmt, plan
  - deploy # terraform apply

workflow:
  rules: # avoid merge request event for general scope
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
      when: never
    - if: '$CI_PIPELINE_SOURCE == "push"'
    - if: '$CI_PIPELINE_SOURCE == "web"'

variables:
  GRADLE_IMAGE: gradle:jdk11
  AWS_CLI_IMAGE: amazon/aws-cli
  TERRAFORM_IMAGE: todo

build-jar: # package app into runnable JAR
  stage: build
  image: $GRADLE_IMAGE
  script:
   - export GRADLE_USER_HOME=`pwd`/.gradle
   - chmod +x gradlew
   - ./gradlew bootJar
   - export ARTIFACT_JAR_NAME=$(ls ./build/libs)
   - echo "Packaged app JAR $ARTIFACT_JAR_NAME"
   - export ARTIFACT_NAME=${ARTIFACT_JAR_NAME%????}
   - echo "Artifact name without .jar is $ARTIFACT_NAME"
   - echo "ARTIFACT_NAME=$ARTIFACT_NAME" >> ./package.env
   - echo "Exporting $ARTIFACT_NAME as variable for next jobs..."
  cache:
    key: "$CI_COMMIT_SHORT_SHA"
    paths:
      - build
      - .gradle
  artifacts:
    paths:
      - build/libs
      - ./package.env
    reports:
      dotenv: ./package.env
    expire_in: 1 hour

upload-jar: # upload runnable JAR to S3 -> to be downloaded to EC2 instance
  stage: publish
  image: $AWS_CLI_IMAGE
  script:
    - export ARTIFACT_VERSIONED_NAME="$ARTIFACT_NAME_$CI_COMMIT_SHORT_SHA"
    - echo "Versioned artifact name based on commit hash is $ARTIFACT_VERSIONED_NAME"
    - echo "Uploading artifact $ARTIFACT_NAME.jar as $ARTIFACT_VERSIONED_NAME.jar" to S3 bucket $ARTIFACTS_BUCKET_NAME"
    - aws s3 cp ./build/libs/$ARTIFACT_NAME.jar s3://${ARTIFACTS_BUCKET_NAME}/$ARTIFACT_VERSIONED_NAME.jar
    - echo "Artifact upload successful"
    - echo "ARTIFACT_VERSIONED_NAME=$ARTIFACT_VERSIONED_NAME" >> ./upload.env
    - echo "Exporting $ARTIFACT_VERSIONED_NAME as variable for next jobs..."
  dependencies:
    - build-jar
  artifacts:
    paths:
      - ./upload.env
    reports:
      dotenv: ./upload.env
  only:
    - main

delete-jar: # cleanup job -> delete JAR from artifacts bucket
  stage: publish
  image: $AWS_CLI_IMAGE
  script:
    - echo "Deleting artifact $ARTIFACT_VERSIONED_NAME.jar from s3 bucket $ARTIFACTS_BUCKET_NAME"
    - aws s3 rm s3://${ARTIFACTS_BUCKET_NAME}/$ARTIFACT_VERSIONED_NAME.jar
    - echo "Artifact successfully removed from S3 bucket $ARTIFACTS_BUCKET_NAME"
  dependencies:
    - build-jar
    - upload-jar
  only:
    - main
  when: manual
  allow_failure: true

spotless-check:
  stage: test
  script:
    - export GRADLE_USER_HOME=`pwd`/.gradle
    - chmod +x gradlew
    - echo "Performing spotless check"
    - ./gradlew spotlessCheck
  except:
    variables:
      - $SKIP_SPOTLESS_CHECK

unit-test:
  stage: test
  script:
    - export GRADLE_USER_HOME=`pwd`/.gradle
    - chmod +x gradlew
    - echo "Running unit tests..."
    - ./gradlew test
  cache:
    key: "$CI_COMMIT_SHORT_SHA"
    policy: pull
    paths:
      - build
      - .gradle

integration-test:
  stage: test
  script:
    - export GRADLE_USER_HOME=`pwd`/.gradle
    - chmod +x gradlew
    - echo "Running integration tests..."
    - ./gradlew integrationTest
  cache:
    key: "$CI_COMMIT_SHORT_SHA"
    policy: pull
    paths:
      - build
      - .gradle
