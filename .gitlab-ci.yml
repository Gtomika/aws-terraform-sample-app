stages:
  - build # build app and upload JAR to S3
  - publish # artifact management
  - test # run tests and checks
  - terraform # terraform init, fmt, plan
  - deploy # terraform apply

workflow:
  rules: # avoid merge request event for general scope
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
      when: never
    - if: '$CI_PIPELINE_SOURCE == "push"'
    - if: '$CI_PIPELINE_SOURCE == "web"'

variables:
  GRADLE_IMAGE: gradle:jdk11
  AWS_CLI_IMAGE: amazon/aws-cli
  TERRAFORM_IMAGE: todo

build-jar: # package app into runnable JAR
  stage: build
  image: $GRADLE_IMAGE
  script:
   - export GRADLE_USER_HOME=`pwd`/.gradle
   - chmod +x gradlew
   - ./gradlew bootJar
   - export ARTIFACT_JAR_NAME=$(ls ./build/libs)
   - echo Packaged app JAR "$ARTIFACT_JAR_NAME"
   - export ARTIFACT_NAME=${ARTIFACT_JAR_NAME%????}
   - echo Artifact name without .jar is "$ARTIFACT_NAME"
   - echo "ARTIFACT_NAME=$ARTIFACT_NAME" >> ./package.env
   - echo Exporting "$ARTIFACT_NAME" as variable for next jobs...
  cache:
    key: "$CI_COMMIT_SHORT_SHA"
    paths:
      - build
      - .gradle
  artifacts:
    paths:
      - build/libs
      - ./package.env
    expire_in: 1 hour

upload-jar: # upload runnable JAR to S3 -> to be downloaded to EC2 instance
  stage: publish
  image: $AWS_CLI_IMAGE
  script:
    - export $(grep -v '^#' package.env | xargs)
    - export ARTIFACT_VERSIONED_NAME="$ARTIFACT_NAME"_"$CI_COMMIT_SHORT_SHA"
    - echo Versioned artifact name based on commit hash is "$ARTIFACT_VERSIONED_NAME"
    - echo Uploading artifact "$ARTIFACT_NAME".jar as "$ARTIFACT_VERSIONED_NAME".jar to S3 bucket "$ARTIFACTS_BUCKET_NAME"
    - aws s3api put-object --bucket $ARTIFACTS_BUCKET_NAME --key "$ARTIFACT_VERSIONED_NAME".jar --body ./build/libs/"$ARTIFACT_NAME".jar
    - echo Artifact upload successful
    - echo "ARTIFACT_VERSIONED_NAME=$ARTIFACT_VERSIONED_NAME" >> ./upload.env
    - echo Exporting "$ARTIFACT_VERSIONED_NAME" as variable for next jobs...
  dependencies:
    - build-jar
  artifacts:
    paths:
      - ./upload.env
  only:
    - main

delete-jar: # cleanup job -> delete JAR from artifacts bucket
  stage: publish
  image: $AWS_CLI_IMAGE
  script:
    - export $(grep -v '^#' upload.env | xargs)
    - echo Deleting artifact "$ARTIFACT_VERSIONED_NAME".jar from s3 bucket "$ARTIFACTS_BUCKET_NAME"
    - aws s3 rm s3://"$ARTIFACTS_BUCKET_NAME"/"$ARTIFACT_VERSIONED_NAME".jar
    - echo Artifact successfully removed from S3 bucket "$ARTIFACTS_BUCKET_NAME"
  dependencies:
    - upload-jar
  artifacts:
    paths:
      - ./upload.env
  only:
    - main
  when: manual
  allow_failure: true

spotless-check:
  stage: test
  image: $GRADLE_IMAGE
  script:
    - export GRADLE_USER_HOME=`pwd`/.gradle
    - chmod +x gradlew
    - echo "Performing spotless check..."
    - ./gradlew spotlessCheck
  except:
    variables:
      - $SKIP_SPOTLESS_CHECK

unit-test:
  stage: test
  image: $GRADLE_IMAGE
  script:
    - export GRADLE_USER_HOME=`pwd`/.gradle
    - chmod +x gradlew
    - echo "Running unit tests..."
    - ./gradlew test
  cache:
    key: "$CI_COMMIT_SHORT_SHA"
    policy: pull
    paths:
      - build
      - .gradle

integration-test:
  stage: test
  image: $GRADLE_IMAGE
  script:
    - export GRADLE_USER_HOME=`pwd`/.gradle
    - chmod +x gradlew
    - echo "Running integration tests..."
    - ./gradlew integrationTest
  cache:
    key: "$CI_COMMIT_SHORT_SHA"
    policy: pull
    paths:
      - build
      - .gradle
